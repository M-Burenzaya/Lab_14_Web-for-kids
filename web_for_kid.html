<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Web_for_kid</title>

  <style>
    canvas {
      border: 2px solid black;
      display: block;
      margin: 20px auto;
    }

    #score {
      font-size: 24px;
      margin-top: 10px;
      text-align: center;
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas" width="600" height="400"></canvas>

  <div id="score"></div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let isDragging = false;

    let movingShape;
    let movingShapeProperties = {
      square: { x: 260, y: 50, width: 80, height: 80 },
      circle: { x: 300, y: 90, radius: 40 },
      triangle: { x: 250, y: 130, width: 100, height: 80 },
    };

    let center = [
      { shape: "square", x: 300, y: 90 },
      { shape: "traingle", x: 300, y: 170 },
      { shape: "circle", x: 300, y: 90 },
    ];

    let squareColors = ["lightblue", "pink", "lightgreen"];
    let circleColors = ["lightblue", "pink", "lightgreen"];
    let triangleColors = ["lightblue", "pink", "lightgreen"];

    let holes = [
      {
        x: 75,
        y: 200,
        width: 100,
        height: 100,
        shape: "square",
        color: squareColors[
          Math.floor(Math.random() * squareColors.length)
        ],
      },
      {
        x: 300,
        y: 250,
        radius: 50,
        shape: "circle",
        color: circleColors[
          Math.floor(Math.random() * circleColors.length)
        ],
      },
      {
        x: 425,
        y: 300,
        width: 120,
        height: 100,
        shape: "triangle",
        color: triangleColors[
          Math.floor(Math.random() * triangleColors.length)
        ],
      },
    ];

    function rand_shape_color() {
      holes.forEach((hole) => {
        if (hole.shape === "square") {
          hole.color =
            squareColors[
            Math.floor(Math.random() * squareColors.length)
            ];
        } else if (hole.shape === "circle") {
          hole.color =
            circleColors[
            Math.floor(Math.random() * circleColors.length)
            ];
        } else if (hole.shape === "triangle") {
          hole.color =
            triangleColors[
            Math.floor(
              Math.random() * triangleColors.length
            )
            ];
        }
      });
    }

    function draw_holes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      holes.forEach((hole) => {
        ctx.fillStyle = hole.color;

        if (hole.shape === "square") {
          ctx.fillRect(hole.x, hole.y, hole.width, hole.height);
        } else if (hole.shape === "circle") {
          ctx.beginPath();
          ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
          ctx.fill();
        } else if (hole.shape === "triangle") {
          ctx.beginPath();
          ctx.moveTo(hole.x, hole.y);
          ctx.lineTo(
            hole.x + hole.width / 2,
            hole.y - hole.height
          );
          ctx.lineTo(hole.x + hole.width, hole.y);
          ctx.closePath();
          ctx.fill();
        }
      });

      ctx.fillStyle = "blue";
      const shapeProperties = movingShapeProperties[movingShape];

      if (movingShape === "square") {
        ctx.fillRect(
          shapeProperties.x,
          shapeProperties.y,
          shapeProperties.width,
          shapeProperties.height
        );
      } else if (movingShape === "circle") {
        ctx.beginPath();
        ctx.arc(
          shapeProperties.x,
          shapeProperties.y,
          shapeProperties.radius,
          0,
          Math.PI * 2
        );
        ctx.fill();
      } else if (movingShape === "triangle") {
        ctx.beginPath();
        ctx.moveTo(shapeProperties.x, shapeProperties.y);
        ctx.lineTo(
          shapeProperties.x + shapeProperties.width / 2,
          shapeProperties.y - shapeProperties.height
        );
        ctx.lineTo(
          shapeProperties.x + shapeProperties.width,
          shapeProperties.y
        );
        ctx.closePath();
        ctx.fill();
      }
    }

    function updateScore() {
      const scoreDiv = document.getElementById("score");
      scoreDiv.innerHTML += "ðŸŒŸ";
    }

    function draw_shape() {
      const shapes = ["square", "circle", "triangle"];
      movingShape = shapes[Math.floor(Math.random() * shapes.length)];
    }

    let initialClickX, initialClickY;
    let initialShapeX, initialShapeY;
    
    function showCursorPosition(event) {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
    
      if (isDragging && x >= 260 && x <= 340 && y >= 50 && y <= 130) {
        if (!initialClickX && !initialClickY) {
          initialClickX = x;
          initialClickY = y;
    
          initialShapeX = movingShapeProperties[movingShape].x;
          initialShapeY = movingShapeProperties[movingShape].y;
        }

        const offsetX = x - initialClickX;
        const offsetY = y - initialClickY;
  
        movingShapeProperties[movingShape].x = initialShapeX + offsetX;
        movingShapeProperties[movingShape].y = initialShapeY + offsetY;
    
        draw_holes();
      } else {
        initialClickX = null;
        initialClickY = null;
      }
    }

    // Mouse down event listener to start dragging
    canvas.addEventListener("mousedown", function (event) {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      if (x >= 260 && x <= 340 && y >= 50 && y <= 130) {
        isDragging = true;
      }
    });
    
    canvas.addEventListener("mouseup", function () {
      isDragging = false;
    });


    canvas.addEventListener("mousemove", function (event) {
      showCursorPosition(event);
    });
    
    function drawEdges() {
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.rect(260, 50, 80, 80);
      ctx.strokeStyle = 'red';
      ctx.stroke();
      
      
    }
    
    
    
    draw_shape();
    draw_holes();
    
    drawEdges();
    
  </script>
</body>

</html>